#pragma once

#include <cstdint>

// WARNING: This code auto-generated by translate-cascade.cpp !

namespace {
  template <typename M>
  struct lbpcascade_dlibqual0 {
    using methods = M;
    static constexpr auto num_stages = 14;
    static constexpr auto window_width = 24;
    static constexpr auto window_height = 24;
    static constexpr auto stride_table_size = 20;

    static const uint32_t s0f0_bits[];
    static const uint32_t s0f1_bits[];
    static const uint32_t s0f2_bits[];

    template <typename T, typename C>
    static inline bool s0(const T* p, const unsigned* st, C&& c) {
      auto f1a = M::template load<5>(p+st[1]+4,st[5]);
      const auto f1b = M::calc(f1a,c);
      if (s0f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      auto f0a = M::template load<4>(p+6,st[2]);
      const auto f0b = M::calc(f0a,c);
      if (s0f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f2a = M::template load<2>(p+st[0]+11,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s0f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      return false;
    }

    static const uint32_t s1f0_bits[];
    static const uint32_t s1f1_bits[];
    static const uint32_t s1f2_bits[];

    template <typename T, typename C>
    static inline bool s1(const T* p, const unsigned* st, C&& c) {
      auto f0a = M::template load<2>(p+st[1]+9,st[6]);
      const auto f0b = M::calc(f0a,c);
      if (s1f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f2a = M::template load<2>(p+7,st[1]);
      const auto f2b = M::calc(f2a,c);
      if (s1f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f1a = M::template load<3>(p+st[13]+11,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s1f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s2f0_bits[];
    static const uint32_t s2f1_bits[];
    static const uint32_t s2f2_bits[];

    template <typename T, typename C>
    static inline bool s2(const T* p, const unsigned* st, C&& c) {
      auto f2a = M::template load<2>(p+st[8]+9,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s2f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f1a = M::template load<3>(p+st[1]+11,st[2]);
      const auto f1b = M::calc(f1a,c);
      if (s2f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      auto f0a = M::template load<3>(p+st[13]+5,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s2f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    static const uint32_t s3f0_bits[];
    static const uint32_t s3f1_bits[];
    static const uint32_t s3f2_bits[];

    template <typename T, typename C>
    static inline bool s3(const T* p, const unsigned* st, C&& c) {
      auto f2a = M::template load<2>(p+st[1]+12,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s3f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f1a = M::template load<5>(p+st[5]+4,st[4]);
      const auto f1b = M::calc(f1a,c);
      if (s3f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      auto f0a = M::template load<3>(p+st[1]+4,st[2]);
      const auto f0b = M::calc(f0a,c);
      if (s3f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    static const uint32_t s4f0_bits[];
    static const uint32_t s4f1_bits[];
    static const uint32_t s4f2_bits[];

    template <typename T, typename C>
    static inline bool s4(const T* p, const unsigned* st, C&& c) {
      auto f1a = M::template load<1>(p+7,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s4f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      auto f2a = M::template load<4>(p+st[13]+8,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s4f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<4>(p+st[3]+12,st[2]);
      const auto f0b = M::calc(f0a,c);
      if (s4f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    static const uint32_t s5f0_bits[];
    static const uint32_t s5f1_bits[];
    static const uint32_t s5f2_bits[];

    template <typename T, typename C>
    static inline bool s5(const T* p, const unsigned* st, C&& c) {
      auto f2a = M::template load<4>(p,st[7]);
      const auto f2b = M::calc(f2a,c);
      if (s5f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<2>(p+st[1]+6,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s5f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f1a = M::template load<1>(p+14,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s5f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s6f0_bits[];
    static const uint32_t s6f1_bits[];
    static const uint32_t s6f2_bits[];

    template <typename T, typename C>
    static inline bool s6(const T* p, const unsigned* st, C&& c) {
      auto f2a = M::template load<4>(p+5,st[2]);
      const auto f2b = M::calc(f2a,c);
      if (s6f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<4>(p+st[0]+6,st[6]);
      const auto f0b = M::calc(f0a,c);
      if (s6f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f1a = M::template load<2>(p+st[19]+11,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s6f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s7f0_bits[];
    static const uint32_t s7f1_bits[];
    static const uint32_t s7f2_bits[];

    template <typename T, typename C>
    static inline bool s7(const T* p, const unsigned* st, C&& c) {
      auto f0a = M::template load<3>(p+st[1]+1,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s7f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f2a = M::template load<3>(p+14,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s7f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f1a = M::template load<4>(p+st[1]+8,st[5]);
      const auto f1b = M::calc(f1a,c);
      if (s7f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s8f0_bits[];
    static const uint32_t s8f1_bits[];
    static const uint32_t s8f2_bits[];

    template <typename T, typename C>
    static inline bool s8(const T* p, const unsigned* st, C&& c) {
      auto f2a = M::template load<3>(p+st[13]+4,st[2]);
      const auto f2b = M::calc(f2a,c);
      if (s8f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<3>(p+st[1]+14,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s8f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f1a = M::template load<1>(p+st[1]+10,st[5]);
      const auto f1b = M::calc(f1a,c);
      if (s8f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s9f0_bits[];
    static const uint32_t s9f1_bits[];
    static const uint32_t s9f2_bits[];

    template <typename T, typename C>
    static inline bool s9(const T* p, const unsigned* st, C&& c) {
      auto f1a = M::template load<2>(p+st[10]+8,st[1]);
      const auto f1b = M::calc(f1a,c);
      if (s9f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      auto f2a = M::template load<4>(p+st[0]+7,st[2]);
      const auto f2b = M::calc(f2a,c);
      if (s9f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<3>(p+1,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s9f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    static const uint32_t s10f0_bits[];
    static const uint32_t s10f1_bits[];
    static const uint32_t s10f2_bits[];
    static const uint32_t s10f3_bits[];

    template <typename T, typename C>
    static inline bool s10(const T* p, const unsigned* st, C&& c) {
      int rem = 1;
      int sum = -2;

      auto f2a = M::template load<2>(p+st[13]+12,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s10f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<2>(p+st[14]+14,st[2]);
      const auto f0b = M::calc(f0a,c);
      if (s10f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        sum += 1;
      else
        rem -= 1;

      auto f3a = M::template load<1>(p+st[6]+11,st[1]);
      const auto f3b = M::calc(f3a,c);
      if (s10f3_bits[M::get_top(f3b)] & (1u<<M::get_bottom(f3b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else {
        rem -= 1;
        if (rem < 0) return false;
      }

      auto f1a = M::template load<1>(p+st[0]+8,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s10f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s11f0_bits[];
    static const uint32_t s11f1_bits[];
    static const uint32_t s11f2_bits[];
    static const uint32_t s11f3_bits[];

    template <typename T, typename C>
    static inline bool s11(const T* p, const unsigned* st, C&& c) {
      int rem = 1;
      int sum = -2;

      auto f0a = M::template load<2>(p+st[3]+17,st[1]);
      const auto f0b = M::calc(f0a,c);
      if (s11f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f2a = M::template load<1>(p+st[6]+10,st[1]);
      const auto f2b = M::calc(f2a,c);
      if (s11f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        sum += 1;
      else
        rem -= 1;

      auto f3a = M::template load<3>(p+st[13]+4,st[0]);
      const auto f3b = M::calc(f3a,c);
      if (s11f3_bits[M::get_top(f3b)] & (1u<<M::get_bottom(f3b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else {
        rem -= 1;
        if (rem < 0) return false;
      }

      auto f1a = M::template load<1>(p+st[0]+13,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s11f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s12f0_bits[];
    static const uint32_t s12f1_bits[];
    static const uint32_t s12f2_bits[];
    static const uint32_t s12f3_bits[];
    static const uint32_t s12f4_bits[];

    template <typename T, typename C>
    static inline bool s12(const T* p, const unsigned* st, C&& c) {
      int rem = 3;
      int sum = -2;

      auto f4a = M::template load<1>(p+st[10]+13,st[1]);
      const auto f4b = M::calc(f4a,c);
      if (s12f4_bits[M::get_top(f4b)] & (1u<<M::get_bottom(f4b)))
        sum += 1;
      else
        rem -= 1;

      auto f3a = M::template load<2>(p+st[19]+7,st[0]);
      const auto f3b = M::calc(f3a,c);
      if (s12f3_bits[M::get_top(f3b)] & (1u<<M::get_bottom(f3b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else
        rem -= 1;

      auto f2a = M::template load<1>(p+st[1]+11,st[5]);
      const auto f2b = M::calc(f2a,c);
      if (s12f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else
        rem -= 1;

      auto f1a = M::template load<2>(p+st[0]+7,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s12f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else {
        rem -= 1;
        if (rem < 0) return false;
      }

      auto f0a = M::template load<2>(p+st[3]+1,st[1]);
      const auto f0b = M::calc(f0a,c);
      if (s12f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    static const uint32_t s13f0_bits[];
    static const uint32_t s13f1_bits[];
    static const uint32_t s13f2_bits[];
    static const uint32_t s13f3_bits[];
    static const uint32_t s13f4_bits[];

    template <typename T, typename C>
    static inline bool s13(const T* p, const unsigned* st, C&& c) {
      int rem = 3;
      int sum = -2;

      auto f2a = M::template load<1>(p+st[1]+15,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s13f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        sum += 1;
      else
        rem -= 1;

      auto f3a = M::template load<3>(p+st[13]+11,st[2]);
      const auto f3b = M::calc(f3a,c);
      if (s13f3_bits[M::get_top(f3b)] & (1u<<M::get_bottom(f3b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else
        rem -= 1;

      auto f4a = M::template load<1>(p+12,st[1]);
      const auto f4b = M::calc(f4a,c);
      if (s13f4_bits[M::get_top(f4b)] & (1u<<M::get_bottom(f4b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else
        rem -= 1;

      auto f1a = M::template load<2>(p+st[8]+2,st[3]);
      const auto f1b = M::calc(f1a,c);
      if (s13f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else {
        rem -= 1;
        if (rem < 0) return false;
      }

      auto f0a = M::template load<3>(p+st[2]+2,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s13f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    template <typename T>
    static inline int test(const T* p, const unsigned* st) {
      auto c = M::init();
      if (!s0(p,st,c)) return 0;
      if (!s1(p,st,c)) return -1;
      if (!s2(p,st,c)) return -2;
      if (!s3(p,st,c)) return -3;
      if (!s4(p,st,c)) return -4;
      if (!s5(p,st,c)) return -5;
      if (!s6(p,st,c)) return -6;
      if (!s7(p,st,c)) return -7;
      if (!s8(p,st,c)) return -8;
      if (!s9(p,st,c)) return -9;
      if (!s10(p,st,c)) return -10;
      if (!s11(p,st,c)) return -11;
      if (!s12(p,st,c)) return -12;
      if (!s13(p,st,c)) return -13;
      return 1;
    }

    template <typename OutIter, typename T>
    static inline void test_all(OutIter&& out, const T* p, const unsigned* st) {
      auto c = M::init();
      *out = s0(p,st,c);  ++out;
      *out = s1(p,st,c);  ++out;
      *out = s2(p,st,c);  ++out;
      *out = s3(p,st,c);  ++out;
      *out = s4(p,st,c);  ++out;
      *out = s5(p,st,c);  ++out;
      *out = s6(p,st,c);  ++out;
      *out = s7(p,st,c);  ++out;
      *out = s8(p,st,c);  ++out;
      *out = s9(p,st,c);  ++out;
      *out = s10(p,st,c);  ++out;
      *out = s11(p,st,c);  ++out;
      *out = s12(p,st,c);  ++out;
      *out = s13(p,st,c);  ++out;
    }
  };
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s0f0_bits[] = {
    4160u,4096u,21845u,21776u,64u,0u,17492u,21840u
  }; // 28 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s0f1_bits[] = {
    732626986u,50331648u,732627114u,50462720u,524296u,0u,655368u,0u
  }; // 35 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s0f2_bits[] = {
    0u,0u,512u,0u,0u,0u,35470u,35562u
  }; // 16 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s1f0_bits[] = {
    0u,0u,285300191u,285298961u,0u,0u,223u,0u
  }; // 29 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s1f1_bits[] = {
    0u,0u,0u,0u,0u,1077936132u,0u,4098883584u
  }; // 10 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s1f2_bits[] = {
    0u,0u,268435456u,828178432u,0u,0u,4352u,923865344u
  }; // 20 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s2f0_bits[] = {
    0u,0u,0u,0u,0u,0u,0u,2155905152u
  }; // 4 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s2f1_bits[] = {
    2147483648u,2147483648u,1024u,0u,3355494400u,2147483648u,0u,0u
  }; // 10 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s2f2_bits[] = {
    65539u,65537u,196611u,65536u,3u,0u,131074u,0u
  }; // 14 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s3f0_bits[] = {
    2147483648u,3422602240u,524288u,0u,2147483648u,2147483648u,0u,0u
  }; // 11 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s3f1_bits[] = {
    2097152u,536870912u,2097152u,805306368u,10485792u,808452272u,10485920u,3014660272u
  }; // 31 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s3f2_bits[] = {
    786432u,524296u,0u,0u,268372527u,76499467u,10354688u,11010056u
  }; // 44 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s4f0_bits[] = {
    589308467u,570425344u,0u,0u,0u,0u,0u,0u
  }; // 12 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s4f1_bits[] = {
    65536u,65537u,33751040u,196609u,0u,66561u,65537u,5701633u
  }; // 20 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s4f2_bits[] = {
    0u,33685504u,0u,268435520u,2114048u,67108864u,1080049728u,3493871616u
  }; // 18 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s5f0_bits[] = {
    33554432u,791356195u,0u,570556416u,0u,587399170u,0u,33554432u
  }; // 26 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s5f1_bits[] = {
    2u,2051u,69337090u,16899u,3u,65539u,131587u,197123u
  }; // 26 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s5f2_bits[] = {
    61u,852303u,2097184u,263169u,2105512u,136u,2097152u,0u
  }; // 27 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s6f0_bits[] = {
    18874376u,1152u,867893418u,0u,0u,1075074388u,0u,0u
  }; // 29 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s6f1_bits[] = {
    0u,1u,515u,16777987u,2u,4u,33688331u,50332427u
  }; // 26 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s6f2_bits[] = {
    16448u,4096u,33836100u,469783876u,84u,2097152u,16452u,21588u
  }; // 32 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s7f0_bits[] = {
    18809101u,65536u,17629189u,73732u,89063951u,65536u,720901u,0u
  }; // 38 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s7f1_bits[] = {
    17498112u,0u,196608u,0u,143261704u,524288u,9109504u,524288u
  }; // 17 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s7f2_bits[] = {
    0u,0u,16777472u,0u,162u,1024u,592589811u,587203328u
  }; // 27 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s8f0_bits[] = {
    50332463u,53153547u,779u,33685763u,2u,2u,2u,0u
  }; // 35 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s8f1_bits[] = {
    0u,285278208u,65615u,286326785u,1024u,65536u,1027u,0u
  }; // 19 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s8f2_bits[] = {
    84215053u,227344653u,16777216u,262144u,1060978687u,386204417u,50331648u,16777216u
  }; // 59 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s9f0_bits[] = {
    0u,1114112u,0u,274661407u,0u,0u,0u,786440u
  }; // 17 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s9f1_bits[] = {
    16973827u,50528256u,2u,0u,858993195u,855851010u,213002u,0u
  }; // 38 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s9f2_bits[] = {
    20544u,659456u,33586464u,20480u,16448u,2097728u,21568u,20480u
  }; // 27 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s10f0_bits[] = {
    0u,572662335u,1912644266u,572697258u,0u,2u,514u,570434090u
  }; // 45 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s10f1_bits[] = {
    0u,0u,0u,67108864u,0u,0u,0u,1431635204u
  }; // 12 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s10f2_bits[] = {
    0u,256u,0u,512u,0u,67108864u,3225437184u,4110423040u
  }; // 16 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s10f3_bits[] = {
    3u,65537u,269549571u,1114113u,11u,0u,11u,0u
  }; // 18 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s11f0_bits[] = {
    221u,0u,1157628040u,0u,0u,0u,0u,0u
  }; // 11 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s11f1_bits[] = {
    0u,0u,0u,0u,0u,0u,4196352u,43950u
  }; // 12 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s11f2_bits[] = {
    65537u,16842753u,65571u,50397217u,49u,4096u,35u,0u
  }; // 21 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s11f3_bits[] = {
    0u,2101248u,4194304u,4368u,0u,0u,262144u,2155915424u
  }; // 14 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s12f0_bits[] = {
    285217040u,0u,285245452u,0u,0u,1024u,0u,0u
  }; // 11 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s12f1_bits[] = {
    0u,0u,0u,1694761984u,0u,0u,2097168u,1427374080u
  }; // 14 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s12f2_bits[] = {
    0u,1024u,83952899u,67190785u,138u,1154u,171u,0u
  }; // 23 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s12f3_bits[] = {
    65536u,17110273u,17104901u,84738063u,16781313u,17044737u,1900559u,17629197u
  }; // 46 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s12f4_bits[] = {
    4653855u,46074687u,207039491u,50065151u,68157697u,3355143u,67108864u,1048592u
  }; // 79 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s13f0_bits[] = {
    0u,0u,2097152u,2048u,263168u,3072u,0u,2155907200u
  }; // 11 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s13f1_bits[] = {
    0u,17105024u,1u,218955917u,1052945u,34205u,277u,327821u
  }; // 38 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s13f2_bits[] = {
    255790655u,121572911u,139001888u,170593027u,3476480u,84877335u,67108864u,69468164u
  }; // 74 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s13f3_bits[] = {
    16777487u,436018079u,142869516u,8u,170135055u,33557135u,42992136u,8u
  }; // 58 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual0<M>::s13f4_bits[] = {
    37749316u,270009548u,101188640u,8391916u,102760448u,71569676u,512u,2814u
  }; // 46 bits set
}
