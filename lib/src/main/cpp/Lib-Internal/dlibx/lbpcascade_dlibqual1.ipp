#pragma once

#include <cstdint>

// WARNING: This code auto-generated by translate-cascade.cpp !

namespace {
  template <typename M>
  struct lbpcascade_dlibqual1 {
    using methods = M;
    static constexpr auto num_stages = 14;
    static constexpr auto window_width = 24;
    static constexpr auto window_height = 24;
    static constexpr auto stride_table_size = 20;

    static const uint32_t s0f0_bits[];
    static const uint32_t s0f1_bits[];
    static const uint32_t s0f2_bits[];

    template <typename T, typename C>
    static inline bool s0(const T* p, const unsigned* st, C&& c) {
      auto f1a = M::template load<5>(p+st[1]+5,st[5]);
      const auto f1b = M::calc(f1a,c);
      if (s0f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      auto f0a = M::template load<4>(p+6,st[2]);
      const auto f0b = M::calc(f0a,c);
      if (s0f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f2a = M::template load<2>(p+st[0]+7,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s0f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      return false;
    }

    static const uint32_t s1f0_bits[];
    static const uint32_t s1f1_bits[];
    static const uint32_t s1f2_bits[];

    template <typename T, typename C>
    static inline bool s1(const T* p, const unsigned* st, C&& c) {
      auto f0a = M::template load<2>(p+st[1]+9,st[6]);
      const auto f0b = M::calc(f0a,c);
      if (s1f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f2a = M::template load<2>(p+11,st[1]);
      const auto f2b = M::calc(f2a,c);
      if (s1f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f1a = M::template load<3>(p+st[13]+4,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s1f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s2f0_bits[];
    static const uint32_t s2f1_bits[];
    static const uint32_t s2f2_bits[];

    template <typename T, typename C>
    static inline bool s2(const T* p, const unsigned* st, C&& c) {
      auto f2a = M::template load<2>(p+st[8]+9,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s2f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f1a = M::template load<3>(p+st[1]+4,st[2]);
      const auto f1b = M::calc(f1a,c);
      if (s2f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      auto f0a = M::template load<3>(p+st[13]+10,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s2f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    static const uint32_t s3f0_bits[];
    static const uint32_t s3f1_bits[];
    static const uint32_t s3f2_bits[];

    template <typename T, typename C>
    static inline bool s3(const T* p, const unsigned* st, C&& c) {
      auto f2a = M::template load<2>(p+st[1]+6,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s3f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f1a = M::template load<5>(p+st[5]+5,st[4]);
      const auto f1b = M::calc(f1a,c);
      if (s3f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      auto f0a = M::template load<3>(p+st[1]+11,st[2]);
      const auto f0b = M::calc(f0a,c);
      if (s3f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    static const uint32_t s4f0_bits[];
    static const uint32_t s4f1_bits[];
    static const uint32_t s4f2_bits[];

    template <typename T, typename C>
    static inline bool s4(const T* p, const unsigned* st, C&& c) {
      auto f1a = M::template load<1>(p+14,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s4f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      auto f2a = M::template load<4>(p+st[13]+4,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s4f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<4>(p+st[3],st[2]);
      const auto f0b = M::calc(f0a,c);
      if (s4f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    static const uint32_t s5f0_bits[];
    static const uint32_t s5f1_bits[];
    static const uint32_t s5f2_bits[];

    template <typename T, typename C>
    static inline bool s5(const T* p, const unsigned* st, C&& c) {
      auto f2a = M::template load<4>(p+12,st[7]);
      const auto f2b = M::calc(f2a,c);
      if (s5f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<2>(p+st[1]+12,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s5f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f1a = M::template load<1>(p+7,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s5f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s6f0_bits[];
    static const uint32_t s6f1_bits[];
    static const uint32_t s6f2_bits[];

    template <typename T, typename C>
    static inline bool s6(const T* p, const unsigned* st, C&& c) {
      auto f2a = M::template load<4>(p+7,st[2]);
      const auto f2b = M::calc(f2a,c);
      if (s6f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<4>(p+st[0]+6,st[6]);
      const auto f0b = M::calc(f0a,c);
      if (s6f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f1a = M::template load<2>(p+st[19]+7,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s6f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s7f0_bits[];
    static const uint32_t s7f1_bits[];
    static const uint32_t s7f2_bits[];

    template <typename T, typename C>
    static inline bool s7(const T* p, const unsigned* st, C&& c) {
      auto f0a = M::template load<3>(p+st[1]+14,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s7f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f2a = M::template load<3>(p+1,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s7f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f1a = M::template load<4>(p+st[1]+4,st[5]);
      const auto f1b = M::calc(f1a,c);
      if (s7f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s8f0_bits[];
    static const uint32_t s8f1_bits[];
    static const uint32_t s8f2_bits[];

    template <typename T, typename C>
    static inline bool s8(const T* p, const unsigned* st, C&& c) {
      auto f2a = M::template load<3>(p+st[13]+11,st[2]);
      const auto f2b = M::calc(f2a,c);
      if (s8f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<3>(p+st[1]+1,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s8f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f1a = M::template load<1>(p+st[1]+11,st[5]);
      const auto f1b = M::calc(f1a,c);
      if (s8f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s9f0_bits[];
    static const uint32_t s9f1_bits[];
    static const uint32_t s9f2_bits[];

    template <typename T, typename C>
    static inline bool s9(const T* p, const unsigned* st, C&& c) {
      auto f1a = M::template load<2>(p+st[10]+10,st[1]);
      const auto f1b = M::calc(f1a,c);
      if (s9f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      auto f2a = M::template load<4>(p+st[0]+5,st[2]);
      const auto f2b = M::calc(f2a,c);
      if (s9f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<3>(p+14,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s9f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    static const uint32_t s10f0_bits[];
    static const uint32_t s10f1_bits[];
    static const uint32_t s10f2_bits[];
    static const uint32_t s10f3_bits[];

    template <typename T, typename C>
    static inline bool s10(const T* p, const unsigned* st, C&& c) {
      int rem = 1;
      int sum = -2;

      auto f2a = M::template load<2>(p+st[13]+6,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s10f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        return true;

      auto f0a = M::template load<2>(p+st[14]+4,st[2]);
      const auto f0b = M::calc(f0a,c);
      if (s10f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        sum += 1;
      else
        rem -= 1;

      auto f3a = M::template load<1>(p+st[6]+10,st[1]);
      const auto f3b = M::calc(f3a,c);
      if (s10f3_bits[M::get_top(f3b)] & (1u<<M::get_bottom(f3b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else {
        rem -= 1;
        if (rem < 0) return false;
      }

      auto f1a = M::template load<1>(p+st[0]+13,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s10f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s11f0_bits[];
    static const uint32_t s11f1_bits[];
    static const uint32_t s11f2_bits[];
    static const uint32_t s11f3_bits[];

    template <typename T, typename C>
    static inline bool s11(const T* p, const unsigned* st, C&& c) {
      int rem = 1;
      int sum = -2;

      auto f0a = M::template load<2>(p+st[3]+1,st[1]);
      const auto f0b = M::calc(f0a,c);
      if (s11f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      auto f2a = M::template load<1>(p+st[6]+11,st[1]);
      const auto f2b = M::calc(f2a,c);
      if (s11f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        sum += 1;
      else
        rem -= 1;

      auto f3a = M::template load<3>(p+st[13]+11,st[0]);
      const auto f3b = M::calc(f3a,c);
      if (s11f3_bits[M::get_top(f3b)] & (1u<<M::get_bottom(f3b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else {
        rem -= 1;
        if (rem < 0) return false;
      }

      auto f1a = M::template load<1>(p+st[0]+8,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s11f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b)))
        return true;

      return false;
    }

    static const uint32_t s12f0_bits[];
    static const uint32_t s12f1_bits[];
    static const uint32_t s12f2_bits[];
    static const uint32_t s12f3_bits[];
    static const uint32_t s12f4_bits[];

    template <typename T, typename C>
    static inline bool s12(const T* p, const unsigned* st, C&& c) {
      int rem = 3;
      int sum = -2;

      auto f4a = M::template load<1>(p+st[10]+8,st[1]);
      const auto f4b = M::calc(f4a,c);
      if (s12f4_bits[M::get_top(f4b)] & (1u<<M::get_bottom(f4b)))
        sum += 1;
      else
        rem -= 1;

      auto f3a = M::template load<2>(p+st[19]+11,st[0]);
      const auto f3b = M::calc(f3a,c);
      if (s12f3_bits[M::get_top(f3b)] & (1u<<M::get_bottom(f3b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else
        rem -= 1;

      auto f2a = M::template load<1>(p+st[1]+10,st[5]);
      const auto f2b = M::calc(f2a,c);
      if (s12f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else
        rem -= 1;

      auto f1a = M::template load<2>(p+st[0]+11,st[0]);
      const auto f1b = M::calc(f1a,c);
      if (s12f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else {
        rem -= 1;
        if (rem < 0) return false;
      }

      auto f0a = M::template load<2>(p+st[3]+17,st[1]);
      const auto f0b = M::calc(f0a,c);
      if (s12f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    static const uint32_t s13f0_bits[];
    static const uint32_t s13f1_bits[];
    static const uint32_t s13f2_bits[];
    static const uint32_t s13f3_bits[];
    static const uint32_t s13f4_bits[];

    template <typename T, typename C>
    static inline bool s13(const T* p, const unsigned* st, C&& c) {
      int rem = 3;
      int sum = -2;

      auto f2a = M::template load<1>(p+st[1]+6,st[0]);
      const auto f2b = M::calc(f2a,c);
      if (s13f2_bits[M::get_top(f2b)] & (1u<<M::get_bottom(f2b)))
        sum += 1;
      else
        rem -= 1;

      auto f3a = M::template load<3>(p+st[13]+4,st[2]);
      const auto f3b = M::calc(f3a,c);
      if (s13f3_bits[M::get_top(f3b)] & (1u<<M::get_bottom(f3b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else
        rem -= 1;

      auto f4a = M::template load<1>(p+9,st[1]);
      const auto f4b = M::calc(f4a,c);
      if (s13f4_bits[M::get_top(f4b)] & (1u<<M::get_bottom(f4b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else
        rem -= 1;

      auto f1a = M::template load<2>(p+st[8]+16,st[3]);
      const auto f1b = M::calc(f1a,c);
      if (s13f1_bits[M::get_top(f1b)] & (1u<<M::get_bottom(f1b))) {
        sum += 1;
        if (sum >= 0) return true;
      }
      else {
        rem -= 1;
        if (rem < 0) return false;
      }

      auto f0a = M::template load<3>(p+st[2]+13,st[0]);
      const auto f0b = M::calc(f0a,c);
      if (s13f0_bits[M::get_top(f0b)] & (1u<<M::get_bottom(f0b)))
        return true;

      return false;
    }

    template <typename T>
    static inline int test(const T* p, const unsigned* st) {
      auto c = M::init();
      if (!s0(p,st,c)) return 0;
      if (!s1(p,st,c)) return -1;
      if (!s2(p,st,c)) return -2;
      if (!s3(p,st,c)) return -3;
      if (!s4(p,st,c)) return -4;
      if (!s5(p,st,c)) return -5;
      if (!s6(p,st,c)) return -6;
      if (!s7(p,st,c)) return -7;
      if (!s8(p,st,c)) return -8;
      if (!s9(p,st,c)) return -9;
      if (!s10(p,st,c)) return -10;
      if (!s11(p,st,c)) return -11;
      if (!s12(p,st,c)) return -12;
      if (!s13(p,st,c)) return -13;
      return 1;
    }

    template <typename OutIter, typename T>
    static inline void test_all(OutIter&& out, const T* p, const unsigned* st) {
      auto c = M::init();
      *out = s0(p,st,c);  ++out;
      *out = s1(p,st,c);  ++out;
      *out = s2(p,st,c);  ++out;
      *out = s3(p,st,c);  ++out;
      *out = s4(p,st,c);  ++out;
      *out = s5(p,st,c);  ++out;
      *out = s6(p,st,c);  ++out;
      *out = s7(p,st,c);  ++out;
      *out = s8(p,st,c);  ++out;
      *out = s9(p,st,c);  ++out;
      *out = s10(p,st,c);  ++out;
      *out = s11(p,st,c);  ++out;
      *out = s12(p,st,c);  ++out;
      *out = s13(p,st,c);  ++out;
    }
  };
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s0f0_bits[] = {
    4160u,4096u,21845u,21776u,64u,0u,17492u,21588u
  }; // 28 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s0f1_bits[] = {
    733675530u,50331648u,1002110986u,50462720u,524296u,0u,655368u,0u
  }; // 35 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s0f2_bits[] = {
    0u,0u,262144u,1426391296u,0u,0u,0u,1427443712u
  }; // 16 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s1f0_bits[] = {
    0u,0u,285300191u,285282577u,0u,0u,16607u,0u
  }; // 29 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s1f1_bits[] = {
    0u,0u,0u,0u,0u,41216u,0u,2155915424u
  }; // 10 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s1f2_bits[] = {
    0u,0u,128u,68u,0u,0u,41951914u,8915182u
  }; // 20 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s2f0_bits[] = {
    0u,0u,0u,0u,0u,0u,0u,4026531840u
  }; // 4 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s2f1_bits[] = {
    2147483648u,3422601216u,1024u,0u,2147483648u,2147483648u,0u,0u
  }; // 10 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s2f2_bits[] = {
    65539u,65537u,196611u,196608u,3u,0u,2u,0u
  }; // 14 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s3f0_bits[] = {
    2147483648u,2147483648u,33554432u,0u,3355495424u,2147483648u,0u,0u
  }; // 11 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s3f1_bits[] = {
    2097152u,540016640u,2097152u,808452096u,8388608u,279969968u,8388736u,2964848888u
  }; // 31 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s3f2_bits[] = {
    33554944u,792668971u,0u,570556960u,50331648u,654789123u,0u,589299712u
  }; // 44 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s4f0_bits[] = {
    16580633u,0u,0u,0u,8912896u,0u,0u,0u
  }; // 12 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s4f1_bits[] = {
    2u,0u,655362u,3u,3u,1027u,131075u,139811u
  }; // 20 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s4f2_bits[] = {
    0u,2375680u,0u,2158592u,655360u,2048u,4224u,2147541120u
  }; // 18 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s5f0_bits[] = {
    524288u,0u,0u,0u,184485903u,9109514u,9043968u,524288u
  }; // 26 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s5f1_bits[] = {
    65536u,65537u,2295808u,458753u,67174401u,65539u,344065u,458755u
  }; // 26 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s5f2_bits[] = {
    17826065u,292552704u,3145728u,2097152u,50402055u,285212672u,1537u,0u
  }; // 27 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s6f0_bits[] = {
    18874376u,0u,867893418u,0u,268436480u,55156u,0u,0u
  }; // 29 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s6f1_bits[] = {
    0u,65536u,327681u,84869125u,1u,256u,327693u,17629197u
  }; // 26 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s6f2_bits[] = {
    20480u,4368u,67655424u,20736u,64u,2097152u,134241732u,21840u
  }; // 32 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s7f0_bits[] = {
    50463535u,50801419u,33555211u,33685763u,2u,2u,4194562u,0u
  }; // 38 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s7f1_bits[] = {
    33685514u,721551360u,131074u,570556418u,0u,33554432u,0u,33554432u
  }; // 17 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s7f2_bits[] = {
    0u,269549568u,12u,283062397u,0u,1024u,0u,9175052u
  }; // 27 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s8f0_bits[] = {
    18678029u,65536u,17104901u,65536u,120521743u,65536u,720901u,0u
  }; // 35 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s8f1_bits[] = {
    0u,1024u,16847107u,66561u,138u,2u,171u,0u
  }; // 19 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s8f2_bits[] = {
    16781071u,536682495u,8u,524296u,721423119u,789135u,512u,8u
  }; // 59 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s9f0_bits[] = {
    0u,0u,0u,0u,34u,0u,50537395u,50332160u
  }; // 17 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s9f1_bits[] = {
    196619u,33489131u,65536u,16990210u,655370u,9126026u,0u,0u
  }; // 38 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s9f2_bits[] = {
    20544u,20480u,72893508u,21568u,33685568u,2363392u,16448u,16448u
  }; // 27 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s10f0_bits[] = {
    0u,0u,1373470848u,327680u,33489169u,65536u,1442775040u,31260672u
  }; // 45 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s10f1_bits[] = {
    0u,0u,0u,0u,0u,0u,2048u,44974u
  }; // 12 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s10f2_bits[] = {
    0u,0u,0u,2147542016u,4u,2048u,262144u,2155908296u
  }; // 16 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s10f3_bits[] = {
    65537u,16842753u,65699u,16842753u,3u,0u,35u,0u
  }; // 18 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s11f0_bits[] = {
    285217041u,0u,285247496u,0u,0u,0u,0u,0u
  }; // 11 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s11f1_bits[] = {
    0u,0u,0u,67117056u,0u,0u,0u,1431634180u
  }; // 12 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s11f2_bits[] = {
    3u,1048593u,1114115u,1114113u,11u,64u,1572875u,0u
  }; // 21 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s11f3_bits[] = {
    0u,0u,8192u,512u,2097216u,0u,84u,4098883584u
  }; // 14 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s12f0_bits[] = {
    220u,0u,1090519432u,0u,0u,1024u,0u,0u
  }; // 11 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s12f1_bits[] = {
    0u,0u,0u,2097168u,0u,0u,8424968u,35496u
  }; // 14 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s12f2_bits[] = {
    0u,285278208u,68623u,286326785u,1024u,268502016u,18435u,0u
  }; // 23 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s12f3_bits[] = {
    2u,73u,779u,50397987u,1615u,1613u,50400011u,50332427u
  }; // 46 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s12f4_bits[] = {
    17244951u,2085u,205729315u,2048u,658441015u,6750563u,2004841779u,48u
  }; // 79 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s13f0_bits[] = {
    0u,1536u,2097152u,0u,0u,67109888u,67108864u,4093640704u
  }; // 11 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s13f1_bits[] = {
    0u,117u,1u,277u,268435978u,1358955797u,452987659u,285213443u
  }; // 38 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s13f2_bits[] = {
    255790907u,69207586u,168828930u,2048u,121573163u,37948187u,237961223u,2099968u
  }; // 74 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s13f3_bits[] = {
    16843021u,221054721u,687867648u,554434592u,1059398655u,353173761u,16777216u,16777216u
  }; // 58 bits set
  template <typename M>
  const uint32_t lbpcascade_dlibqual1<M>::s13f4_bits[] = {
    798976u,2623488u,35130368u,262144u,318772640u,16788292u,890246400u,353702160u
  }; // 46 bits set
}
